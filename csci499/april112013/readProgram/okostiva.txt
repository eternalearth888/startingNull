	The Nerd.java class seems to be the player's character. The attributes for this class are name, picture, and list of weapons. The default constructor for Nerd is an unknown name, no pictures, and an empty ArrayList. It then has a constructor for which we can pass in a name and image too. I believe this can be refactored as follows:

	public Nerd(String name, Image image, String imagePath) {
		this.name = name;
		this.image = image;
		this.imagePath = ToolKit.getDefaultToolKit().getImage(imagePath);
		weapons = new ArrayList<Weapon>();
	}

	OR

	public Nerd(string name, Image image) {
		this.name = namel
		this.image = image;
		weapons = new ArrayList<Weapon>();
	}

	public grabImage(String imagePath) {
		this.imagePath = ToolKit.getDefaultToolKit().getImage(imagePath);
	}

	I feel that something along these lines will help with keeping code DRY. Hopefully, I am not misinterpreting this part.
	The Weapon.java class is used as the parent class for all the weapons the group has created for this game. They first declare the three types of weapons they have created which are pencil, protractor and book. The attributes of all weapons are damage, its picture, its position on the game board, the level of weapon it is and the type of weapon it is. These are all protected since only the parent and children classes are concerned with this. The default constructor for the weapon is level 0, damage 0, and no weapon at all. Otherwise, we pass in the amount of damage, the level of the weapon, and its type. It's interesting to see how they also pass in an image parameter, but what I find most interesting is that they have another default constructor that practically does the same thing - except that this one passes in the image path. Just like the example nerd code above. Otherwise, it just looks like they are repeating some code.
	They also have a function called translate. After tracing it carefully, it seems to be that it tells the user if they are making a valid move or not after calculating their angle and power from the current position passed through. I would refactor this only slightly to give it a more meaningful name such as:

	isValidMove

	The Book.java class has one attribute which is to give the subject to the book. The default uses super to call the constructor, propeties, and method of the parent class (which is Weapon.java) in this case. The book is given a damage parameter, a level and a weapon type which it then uses the parent class to determine those values. The book is drawn, and getWeaponName is overriden so that when used it will return Book. This tells me that the Book in this game is a weapon. (Which we already knew from reading the Weapon class before).
	The Protractor.java class is similar to the Book.java class. Its defautl constructor uses super to call the constructor, properties, and methods of the parent class (Weapon.java). It's drawn and it gets its weapon name. At first I thought that this wasn't as thorough as the Book.java class - but then I realized that it didn't need to be. All it needs is the name, level, damage, and weapon type.
	The Pencil.java class is in the same boat as the Protractor.java class. Only needs super to use constructor, properties, and methods of the parent (Weapon.java) class. It simply needs to be drawn, get its name, level, damage and weapon type. Straight forward and to the point.
	There is another parent class called Target.java in this project. This tells me that there may be different types of targets in the game that share the same attributes. Targets have a position on the board, a set amount of health, a specific level they are at, and certain amount of points that the player recieves when they defeat them. They also have an image attribute and a boolean to determine if the target was destroyed or not. All default constructor sets health, position, level to 0, the target as not destroyed, and no image. Otherwise, we can set the position and what not by simply passing in those values to the parameter. Once again, similar to the Weapons.java class they have one constructor for passing in the image and another for reading the image path. Perhaps this is done so that it will be easier to find the search path, but right now, I just see it would be simpler to do some refactoring similar to what I did for Weapons.java.
	Bully.java class is a child of the Target class. It's default constructor uses the super to use the constructor, properties and methods of its parent class (Target.java) and gives an unknown name to the Bully. Otherwise the Bully is given their position on the gameboard, a set amount of health, how many points they are worth, what level they are, a name and an imagePath. Also has similar "issue" that Nerd.java has.
	The Exam.java class is a child to the parent class Target.java as well. Similar to the Bully.java class. Only main difference is that the Exam class also has an attribute for the subject of the Exam.
 	Window.java class is also a child to the parent class Target.java as well. It has similar methods to that of the Bully.java class.
	The HelpNotes.java class contain the main instructions of the game
	The Gameboard.java class contains the difficulty choices for the game. After skimming through it seems that it creates the gui (the gameboard) and brings all the other classes together to make the game. It initializes weapons, the bully, the nerd, etc. It also creates the menu and the timer.
	The ControlPanel.java craetes the part of the game that the user is allowed to interface with. It grabs the users choices and tells the game to run accordingly.