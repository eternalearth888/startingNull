	I like that they broke down so many main ideas into individual classes. 

	For example, world.java does nothing but create and instatiate the game. It creates and stores the questions, draws the background, the launcher, the projectiles, and the targets. Very simple and clean. I also have never seen the following for loop structure, ex:
	
	for ( Projectile p : projectiles ) { p.draw(g) }
	
	At first I thought it was something very complicated, but after thinking about it a little, I realize that all it is really saying is for each projectile object in the list, draw it.
	The world.java class also helps with playing the game. It checks if a projectile has collided with a target, moving a projectile, and asking questions.
	What I found most interesting was their run function at the bottom of the class - it is actually an Override function. But it's not that it was an override function that I found interesting, but some kind of statement called: 

	synchronized(something);

	I never heard of it before. After a little research I found out that synchrnoized statements are useful for updating specific fields without affecting any other fields in a class. So what they are saying in their code, to the best of my understanding, is that they want to update the projectile as it moves, without anything else (like the targets) changing. I can see some really great potentials for this in algorithms and databases.

	Target.java is clearly the class that deals with the targets of their game. It creates and draws multiple targest in different locations, checks to see whether a target has been hit, and what location the target was hit.I like that they overrided the compareTo function, so that they could keep the meaningful name for their class.

	Projectile.java is the class that deals specifically with the projectiles of their game. It contains the size of the projectile, as well as the current (x,y) coordinates of the projectile and the velocity of the projectile at those specific coordinates. I like that they had one specific function to calculate the speed of the projectile, and I find it interesting that they have no parameters for it. I would assume that this means that they would have something along the lines of projectile.calculateSpeed() where it then would simply return the current speed of that specific projectile object. I also find it interesting that in order to change the position and velocity of the projectile they have function called move that passes in the change in time (deltaTime) and they are able to use that parameter to calculate the new positicon and velocity in such a simple manner.

	Launcher.java is the class that deals specifically with the launcher of the game. The default constructor for it calls the world, the default angle and power, and draws the default projectile path. It will constantly redraw the projectile path everytime it changes. I especially like that they had a reset function - this tells me they have a reset button for their game as well.

	Controls.java is the class that deals specifically with the controls. And boy, are there some controls!!  I see that they have text fields, buttons, sliders, and labels. Based on the name of the sliders, it is clear to see that they are for the power level and the angle of the launcher/projectile. This, in my mind, seems to allow for more accurate and diverse set of choices for the player to play with. Their default constructor is big, but with good reason it seems. They first call the world class, set up the panel, and create the elements. They then begin to add elements to the panel followed by listeners for the elements (generate the element and clear the element).This process repeats for every specific set of panels that they need. The rest of the functions focus on making listener classes for the slider, text fields, and buttons.

	AngleGame.java seems to focus on taking all the other classes and pulling them all together to make the game a reality. It creates the GUI window for the game, creates the layout, the world and sets the controls. And it adds the menu bar to the GUI.

	FinalProjectTests.java clearly tests parts of the game. They test on the three main things of the game, which is creating projectiles, testing collisons, making sure that projectile movement is correct, the targest are generated correctly, and that their calculations for calculating speed is also correct. Although there only seems to be a couple of test functions, each function has around 2-3 different asserts inside of it - so this ensures that they are checking more than one case. I also like that they tested that things were not only correct but making sure that things were wrong as well. As far as I can tell, they seem to have a lot of their bases covered. 

	This team did a great job with their code!



